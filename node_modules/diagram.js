function diagramInit(loadFile){
  
  var $ = go.GraphObject.make;

  var myDiagram = $(go.Diagram, "myDiagramDiv",
                {
                  initialContentAlignment: go.Spot.Center,
                  "undoManager.isEnabled": true,
                  "isReadOnly": true,
                });

  // define a simple Node template. This should go first after defining diagram.
  myDiagram.nodeTemplate =
    $(go.Node,
      { 
        locationSpot: go.Spot.TopLeft,
        locationObjectName: "SHAPE",
        resizable: true,
        // mouseEnter: function (e, obj) { showPoint(obj.part.location); },
        // click: function (e, obj) { showPoint(obj.part.location); }
      },
      new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
      new go.Binding("movable", "canMove"),
      $(go.Shape,
        {stroke: null, name: "SHAPE"},
        new go.Binding("shape", "figure"),
        new go.Binding("fill", "color"),
        new go.Binding("width", "width").makeTwoWay(),
        new go.Binding("height", "height").makeTwoWay()),
      $(go.TextBlock,
        { font: "10px sans-serif", textAlign: "center", verticalAlignment: go.Spot.Center, name: "TEXT" },
        new go.Binding("text", "key"),
        new go.Binding("width", "width"),
        new go.Binding("height", "height"))
    );

    myDiagram.linkTemplateMap.add("Dimensioning", 
        $(DimensioningLink,
          new go.Binding("fromSpot", "fromSpot", go.Spot.parse),
          new go.Binding("toSpot", "toSpot", go.Spot.parse),
          new go.Binding("direction"),
          new go.Binding("extension"),
          new go.Binding("inset"),
          $(go.Shape, { stroke: "gray" }),
          $(go.Shape, { fromArrow: "BackwardOpenTriangle", segmentIndex: 2, stroke: "gray" }),
          $(go.Shape, { toArrow: "OpenTriangle", segmentIndex: -3, stroke: "gray" }),
          $(go.TextBlock,
            {
              segmentIndex: 2,
              segmentFraction: 0.5,
              segmentOrientation: go.Link.OrientUpright,
              alignmentFocus: go.Spot.Bottom,
              stroke: "gray",
              font: "8pt sans-serif"
            },
            new go.Binding("text", "", showDistance).ofObject(),
            new go.Binding("stroke", "color"))
        ));
  
  //Will only actually need front offset for calculation of Y coordinate.
  var offsetX = 0;
  for(item in loadFile.nodeDataArray){
    for(key in loadFile.nodeDataArray[item]){
      if(key === "width" || key === "height" || key === "frontOffset" || key == "backOffset"){
        loadFile.nodeDataArray[item][key] = loadFile.nodeDataArray[item][key] / 20;
      }
    }
    if(item > 0){
      offsetX = offsetX + loadFile.nodeDataArray[item-1].width;
      loadFile.nodeDataArray[item].loc = ComputeLocationFromJsonModel(loadFile.nodeDataArray[item-1].frontOffset, 
                      loadFile.nodeDataArray[item].frontOffset,
                      offsetX);
    }
  }

  loadFile.linkDataArray = DimensionBuilder(loadFile);
  myDiagram.model = go.Model.fromJson(loadFile);
  InputIterationBuilder(loadFile, myDiagram);
  
  for(var i = 1; i <= myDiagram.model.nodeDataArray.length; i++){
    var elementWidth = document.getElementById("width"+myDiagram.model.nodeDataArray[i-1].key);
    var elementHeight = document.getElementById("height"+myDiagram.model.nodeDataArray[i-1].key);

    elementWidth.addEventListener("blur", function(){
      var newWidth = this.value / 20;
      var key = this.id.replace("width", "");
      node = myDiagram.findNodeForKey(key);

      if(node.data.width != newWidth){
        var prevWidth = node.data.width;
        myDiagram.startTransaction("Change width for " + node.key);
        myDiagram.model.setDataProperty(node.data, "width", newWidth);
        myDiagram.commitTransaction("Change width for " + node.key);

        adjustX = newWidth - prevWidth;

        AdjustSiblingPositions(myDiagram, node, prevWidth, adjustX, node.data.key);
      }
    });

    elementHeight.addEventListener("blur", function(){
      var newHeight = this.value / 20;
      var key = this.id.replace("height", "");
      node = myDiagram.findNodeForKey(key);

      if(node.data.height != newHeight){
        myDiagram.startTransaction("Change height for " + node.key);
        myDiagram.model.setDataProperty(node.data, "height", newHeight);
        myDiagram.commitTransaction("Change height for " + node.key);

        var updatedDimensions = DimensionBuilder(myDiagram.model);
        myDiagram.startTransaction("Reconstruct dimensions after update.");
        myDiagram.model.linkDataArray = updatedDimensions;
        myDiagram.commitTransaction("Reconstruct dimensions after update.");
      }
    });

    if(i < myDiagram.model.nodeDataArray.length){
      var elementFrontOffset = document.getElementById("frontOffset"+myDiagram.model.nodeDataArray[i].key);
      
      elementFrontOffset.addEventListener("blur", function(){
        var newFrontOffset = this.value / 20;
        var key = this.id.replace("frontOffset", "");
        node = myDiagram.findNodeForKey(key);

        if((node.data.frontOffset / 20) != newFrontOffset){
          myDiagram.startTransaction("Change offset for " + node.key);
          originalLocation = node.data.loc.split(" ");
          newLocation = originalLocation[0] + " " + newFrontOffset;

          myDiagram.model.setDataProperty(node.data, "frontOffset", newFrontOffset * 20);
          myDiagram.model.setDataProperty(node.data, "loc", newLocation);
          myDiagram.commitTransaction("Change offset for " + node.key);

          var updatedDimensions = DimensionBuilder(myDiagram.model);
          myDiagram.startTransaction("Reconstruct dimensions after update.");
          myDiagram.model.linkDataArray = updatedDimensions;
          myDiagram.commitTransaction("Reconstruct dimensions after update.");
        }
      });
    }
  }

  //Setting the grids on diagram
  myDiagram.grid = $(go.Panel, "Grid",
        { gridCellSize: new go.Size(20,20), visible: true },
        $(go.Shape, "LineH", { stroke: "lightgray" }),
        $(go.Shape, "LineV", { stroke: "lightgray" }));

  myDiagram.toolManager.draggingTool.isGridSnapEnabled = true;
  myDiagram.toolManager.draggingTool.gridSnapCellSize = new go.Size(10,10);
}

//Custom Methods for additional computation starts from here.
var ComputeLocationFromJsonModel = function(prevOffset, currentOffset, prevItemWidth){
  return loc = prevOffset == currentOffset ? prevItemWidth + " 0" : prevItemWidth + " " + currentOffset;
};

var AdjustSiblingPositions = function(diagram, node, prevWidth, adjustX, parentNodeKey){
  var model = diagram.model.nodeDataArray;
  var thisNode = typeof(node.data) === "undefined" ? node : node.data;
  var thisLocation = thisNode.loc.split(" ");
  for(var i = 0; i < model.length; i++){
    var position = model[i].loc.split(" ");
    if(position[0] == (parseInt(thisLocation[0]) + prevWidth)){
      AdjustSiblingPositions(diagram, model[i], model[i].width, adjustX);
      break;
    }
  }

  if(parentNodeKey != thisNode.key){
    var position = model[model.findIndex(x => x.key == thisNode.key)].loc.split(" ");
    diagram.startTransaction("Adjust positions with respect to " + thisNode.key);
    var adjustNode = diagram.findNodeForKey(thisNode.key);
    var newXPosition = parseInt(position[0]) + adjustX;
    diagram.model.setDataProperty(adjustNode.data, "loc", newXPosition + " " + position[1]);
    diagram.commitTransaction("Adjust positions with respect to " + thisNode.key);
  }
};

var showDistance = function (link) {
  var numpts = link.pointsCount;
  if (numpts < 2) return "";
  var p0 = link.getPoint(0);
  var pn = link.getPoint(numpts - 1);
  var ang = link.direction;
  if (isNaN(ang)) return Math.floor(Math.sqrt(p0.distanceSquaredPoint(pn))) * 20 + "mm";
  var rad = ang * Math.PI / 180;
  return Math.floor(Math.abs(Math.cos(rad) * (p0.x - pn.x)) * 20 +
                    Math.abs(Math.sin(rad) * (p0.y - pn.y))) * 20 + "mm";
}

var DimensionBuilder = function (JsonModel){
  var result = [];
  var linkDataArray = {
    from: "",
    to: "", 
    category: "Dimensioning",
    fromSpot: "",
    toSpot: "",
    extension: 50,
    direction: 0
  };
  for (var i = 1; i < JsonModel.nodeDataArray.length; i++){
    var heightDifference = JsonModel.nodeDataArray[i-1].height - JsonModel.nodeDataArray[i].height;
    var yPosition = JsonModel.nodeDataArray[i].loc.split(" ")[1];
    
    if(heightDifference < 0 || yPosition > 0){
       linkDataArray.from = JsonModel.nodeDataArray[i-1].key;
       linkDataArray.to = JsonModel.nodeDataArray[i].key;
       linkDataArray.fromSpot = "BottomRight";
       linkDataArray.toSpot = "BottomLeft";
       linkDataArray.direction = 270;

       result.push(linkDataArray);
    } else if (heightDifference > 0 || yPosition < 0) {
      linkDataArray.from = JsonModel.nodeDataArray[i-1].key;
       linkDataArray.to = JsonModel.nodeDataArray[i].key;
       linkDataArray.fromSpot = "BottomRight";
       linkDataArray.toSpot = "BottomLeft";
       linkDataArray.direction = 90;

       result.push(linkDataArray);
    }

    if (yPosition < 0){
      linkDataArray = {
        from: "",
        to: "", 
        category: "Dimensioning",
        fromSpot: "",
        toSpot: "",
        extension: 50,
        direction: 0
      };

      linkDataArray.from = JsonModel.nodeDataArray[i-1].key;
       linkDataArray.to = JsonModel.nodeDataArray[i].key;
       linkDataArray.fromSpot = "TopRight";
       linkDataArray.toSpot = "TopLeft";
       linkDataArray.direction = 270;

       result.push(linkDataArray);
    }

    linkDataArray = {
      from: "",
      to: "", 
      category: "Dimensioning",
      fromSpot: "",
      toSpot: "",
      extension: 50,
      direction: 0
    };
  }

  return result;
}
//Custom Methods for additional computation ends to here.